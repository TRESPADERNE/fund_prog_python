
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Funciones. Conceptos avanzados. &#8212; Fundamentos de Programación en Python</title>
    
  <link rel="stylesheet" href="../../_static/css/index.73d71520a4ca3b99cfee5594769eaaae.css">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/sphinx-book-theme.40e2e510f6b7d1648584402491bb10fe.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.3da636dd464baa7582d2.js">

    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/sphinx-book-theme.d31b09fe5c1d09cb49b26a786de4a05d.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../../index.html">
  
  <img src="../../_static/logo.png" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Fundamentos de Programación en Python</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../0_Python/Introduccion_Python.html">
   Introducción a Python
  </a>
 </li>
</ul>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../1_Expresiones_operadores_y_tipos_de_datos/Expresiones_operadores_y_tipos_de_datos.html">
   Operadores, expresiones y tipos de datos
  </a>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/notebooks/17_Funciones_conceptos_avanzados/Funciones_conceptos_avanzados.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

        <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://https://github.com/TRESPADERNE/fund_prog_python"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://https://github.com/TRESPADERNE/fund_prog_python/issues/new?title=Issue%20on%20page%20%2Fnotebooks/17_Funciones_conceptos_avanzados/Funciones_conceptos_avanzados.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/TRESPADERNE/fund_prog_python/master?urlpath=tree/notebooks/17_Funciones_conceptos_avanzados/Funciones_conceptos_avanzados.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#contenidos">
   Contenidos
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#funciones-puras-e-impuras">
   Funciones puras e impuras
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ventajas-de-las-funciones-puras">
     Ventajas de las funciones puras
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#las-funciones-impuras-son-inevitables">
     Las funciones impuras son inevitables
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#el-mecanismo-de-las-llamadas-a-funciones">
   El mecanismo de las llamadas a funciones
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ejemplo">
     Ejemplo
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#traza-de-un-programa">
     Traza de un programa
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#la-pila-de-llamadas">
     La pila de llamadas
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#alcance-de-las-variables-variables-locales-y-globales">
   Alcance de las variables: variables locales y globales
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#jerarquia-de-acceso-a-los-nombres">
     Jerarquía de acceso a los nombres
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#parametros-de-una-funcion-mutables">
     Parámetros de una función mutables
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#recursividad">
   Recursividad
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#por-que-funciona-la-recursividad">
     ¿Por qué funciona la recursividad?
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#desventajas-de-una-funcion-recursiva-con-respecto-a-la-iterativa">
     Desventajas de una función recursiva con respecto a la iterativa
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#cual-es-entonces-la-utilidad-de-una-solucion-recursiva">
     ¿Cuál es, entonces, la utilidad de una solución recursiva?
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#las-funciones-como-objetos">
   Las funciones como objetos
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#haciendo-que-una-funcion-sea-pura">
     Haciendo que una función sea pura
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#funciones-con-un-numero-indeterminado-de-argumentos">
   Funciones con un número indeterminado de argumentos
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#polimorfismo-con-funciones">
   Polimorfismo con funciones
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#utilizando-introspeccion">
     Utilizando introspección
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#buenas-practicas-en-el-diseno-de-funciones">
   Buenas prácticas en el diseño de funciones
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#temas-avanzados-y-bibliografia-especifica">
   Temas avanzados y bibliografía específica
  </a>
 </li>
</ul>

        </nav>
        
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="funciones-conceptos-avanzados">
<h1>Funciones. Conceptos avanzados.<a class="headerlink" href="#funciones-conceptos-avanzados" title="Permalink to this headline">¶</a></h1>
<p><strong>Autores</strong>: Rogelio Mazaeda, Félix Miguel Trespaderne.</p>
<div class="section" id="contenidos">
<h2>Contenidos<a class="headerlink" href="#contenidos" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="#Funciones_puras_e_impuras">Funciones puras e impuras</a><br>
<a class="reference external" href="#El_mecanismo_de_las_llamadas_a_funciones">El mecanismo de las llamadas a funciones</a><br>
<a class="reference external" href="#Alcance_de_las_variables:_variables_locales_y_globales">Alcance de las variables: variables locales y globales</a><br>
<a class="reference external" href="#Recursividad">Recursividad</a><br>
<a class="reference external" href="#Las_funciones_como_objetos">Las funciones como objetos</a><br>
<a class="reference external" href="#Funciones_con_un_n%C3%BAmero_indeterminado_de_argumentos">Funciones con un número indeterminado de argumentos</a><br>
<a class="reference external" href="#Polimorfismo_con_funciones">Polimorfismo con funciones</a><br>
<a class="reference external" href="#Buenas_pr%C3%A1cticas">Resumen de buenas prácticas</a><br>
<a class="reference external" href="#Temas_avanzados">Temas avanzados y bibliografía específica</a></p>
<p><a id='Funciones_puras_e_impuras'></a></p>
</div>
<div class="section" id="funciones-puras-e-impuras">
<h2>Funciones puras e impuras<a class="headerlink" href="#funciones-puras-e-impuras" title="Permalink to this headline">¶</a></h2>
<p>Las <strong>funciones</strong> de Python que tienen un comportamiento <strong>similar a las funciones matemáticas</strong>, esto es, constituyen una relación unívoca entre el dominio de los valores de entrada y el valor de la salida, se denominan <strong>funciones puras</strong>.</p>
<p><img alt="funcion_pura.jpg" src="notebooks\17_Funciones_conceptos_avanzados\attachment:funcion_pura.jpg" /></p>
<p>Se puede decir de las <strong>funciones puras</strong> que:</p>
<ul class="simple">
<li><p>Devuelven el <strong>mismo resultado</strong> al ser <em>llamadas</em> con los <strong>mismos valores de entrada</strong>.</p></li>
<li><p>El resultado sólo depende de la entrada: no tienen <strong>memoria</strong>, no conservan un <strong>estado</strong> que les permita <em>recordar</em> que la misma ha sido <em>invocada</em> antes, para entonces devolver un valor distinto en llamadas sucesivas.</p></li>
<li><p>No tiene <strong>efectos secundarios</strong> (<strong>side effects</strong>). La única forma de interacción con el resto de programa, o el contexto en que éste se desarrolla, es a través de la sentencia <code class="docutils literal notranslate"><span class="pre">return</span></code>. En especial:</p>
<ul>
<li><p>No modifican <strong>variables globales</strong> (se discute más adelante).</p></li>
<li><p>No imprime nada por pantalla, ni interaccionan de ninguna otra manera con el <em>mundo exterior</em>.</p></li>
</ul>
</li>
</ul>
<p>Las <strong>funciones impuras</strong> son el resto de las funciones. Por ejemplo:</p>
<ul class="simple">
<li><p>Funciones sin parámetros de entrada y/o sin valores devueltos mediante <code class="docutils literal notranslate"><span class="pre">return</span></code>.</p></li>
<li><p>Funciones que devuelven valores diferentes cada vez.</p></li>
<li><p>Funciones que modifican las variables globales o aquellos parámetros que sean <strong>mutables</strong>.</p></li>
</ul>
<div class="section" id="ventajas-de-las-funciones-puras">
<h3>Ventajas de las funciones puras<a class="headerlink" href="#ventajas-de-las-funciones-puras" title="Permalink to this headline">¶</a></h3>
<p>El trabajar preferentemente con <strong>funciones puras</strong> está en la base del <strong>paradigma funcional</strong> de programación, que en los últimos años está recobrando un nuevo auge.</p>
<p>El uso de <strong>funciones puras</strong> permite utilizar en programación las herramientas de análisis en las matemáticas y <em>demostrar</em>, en el sentido matemático del término, la <em>corrección</em> de un programa de ordenador. En cualquier caso, una descripción de los principios y prácticas de la <strong>programación funcional</strong> está fuera de los marcos de este curso introductorio.</p>
<p>Eso no impide que recomendemos, siempre que sea razonable, el uso <strong>funciones puras</strong>:</p>
<ul class="simple">
<li><p>Al <em>prohibir</em> los <em>efectos colaterales</em>, hace que los programas sean más fácilmente depurables.</p></li>
<li><p>Permite además la <strong>composición</strong> de funciones: el pasar como argumentos de funciones, directamente el valor devuelto por otra función (con cualquier grado de anidamiento). Ejemplo: <code class="docutils literal notranslate"><span class="pre">cos(log(x))</span></code>.</p></li>
</ul>
</div>
<div class="section" id="las-funciones-impuras-son-inevitables">
<h3>Las funciones impuras son inevitables<a class="headerlink" href="#las-funciones-impuras-son-inevitables" title="Permalink to this headline">¶</a></h3>
<p>El objetivo de la programación es <strong>aceptar datos</strong> del <em>mundo exterior</em>, <strong>procesarlos</strong> de alguna forma y <strong>devolverlos</strong> al usuario. O sea, la utilidad global de los programas está precisamente en lograr determinados <strong>efectos colaterales</strong>.</p>
<p>En todo caso, resulta útil, confinar estás interacciones con el <strong>mundo exterior</strong> a determinadas funciones bien <em>localizadas</em>.</p>
<p>Ejemplos de funciones impuras imprescindibles o útiles:</p>
<ul class="simple">
<li><p>Las funciones de entrada y salida, utilizando la consola, ficheros o redes informáticas, entre otras:</p></li>
</ul>
<blockquote>
<div><p>Por ejemplo, la función <code class="docutils literal notranslate"><span class="pre">input()</span></code>: aunque sea llamada con el mismo parámetro de entrada, puede devolver cada vez valores diferentes: el usuario humano tiene un <strong>estado</strong> o <strong>memoria</strong>.</p>
</div></blockquote>
<ul class="simple">
<li><p>Función que devuelve un número aleatorio: resulta útil porque precisamente tiene <strong>memoria</strong>: devuelve un valor diferente cada vez.</p></li>
</ul>
<hr class="docutils" />
<p><a id='El_mecanismo_de_las_llamadas_a_funciones'></a></p>
</div>
</div>
<div class="section" id="el-mecanismo-de-las-llamadas-a-funciones">
<h2>El mecanismo de las llamadas a funciones<a class="headerlink" href="#el-mecanismo-de-las-llamadas-a-funciones" title="Permalink to this headline">¶</a></h2>
<p>Como ya se ha dicho, las funciones permiten dar una estructura lógica a un programa al dividirlo en varios subprogramas, cada uno ocupándose de una tarea bien definida.</p>
<p>Este proceso de división del programa tiene un carácter jerárquico: el programa principal, en la parte más alta de la jerarquía, describe la solución desde el punto de vista más general, haciendo uso de las diferentes funciones para resolver las subtareas. Cada función, a su vez, puede ser dividida en otros tantos subproblemas, y así sucesivamente utilizando tantos niveles jerárquicos como se considere necesario.</p>
<p>Durante la ejecución del programa, el proceso de llamadas a funciones y el retorno desde estas, puede ser conceptualmente interpretado como recursos del lenguaje que modifican el flujo normal (secuencial) del programa.</p>
<div class="section" id="ejemplo">
<h3>Ejemplo<a class="headerlink" href="#ejemplo" title="Permalink to this headline">¶</a></h3>
<p>Se sabe de las matemáticas combinatorias que el número de posibilidades de escoger <span class="math notranslate nohighlight">\(k\)</span> elementos en una población de <span class="math notranslate nohighlight">\(n\)</span>, las <strong>combinaciones</strong>, viene dado por la expresión:</p>
<p>\begin{align}
\C_{n,k} = {n \choose k} = \frac {n!}{k!(n-k)!} \
\end{align}</p>
<p>Supongamos que se decide calcular las combinaciones mediante una función de Python, utilizando a su vez otra función que determina el factorial de un número entero.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># calcula factorial de argumento n</span>
<span class="k">def</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">fact</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">fact</span> <span class="o">*=</span> <span class="n">i</span>
    <span class="k">return</span> <span class="n">fact</span>


<span class="c1"># calcula combinaciones de n tomadas k a la vez</span>
<span class="k">def</span> <span class="nf">combinaciones</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">comb</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">:</span>
        <span class="n">comb</span> <span class="o">=</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">factorial</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">k</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">comb</span>


<span class="c1"># Programa principal</span>

<span class="n">elementos</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">muestras</span> <span class="o">=</span> <span class="mi">3</span>
<span class="nb">print</span><span class="p">(</span><span class="n">combinaciones</span><span class="p">(</span><span class="n">elementos</span><span class="p">,</span> <span class="n">muestras</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>10.0
</pre></div>
</div>
</div>
</div>
<p>La estructura del programa anterior se podría visualizar gráficamente como se muestra. Se divide en el programa principal y dos funciones, <code class="docutils literal notranslate"><span class="pre">combinaciones()</span></code> y <code class="docutils literal notranslate"><span class="pre">factorial()</span></code>. Además se utiliza la función <code class="docutils literal notranslate"><span class="pre">print()</span></code>, que es una función nativa.</p>
<p><img alt="combinaciones.jpg" src="../../_images/combinaciones.jpg" /></p>
<p>La información brindada por el esquema se limita básicamente a la estructura estática del programa, aunque con las flechas se muestra desde dónde se realizan las llamadas a las diferentes funciones, lo que indica una especie de jerarquía entre ellas para este ejemplo concreto:</p>
<ol class="simple">
<li><p>El programa principal utiliza la función <code class="docutils literal notranslate"><span class="pre">print()</span></code>.</p></li>
<li><p>A su vez <code class="docutils literal notranslate"><span class="pre">print()</span></code> <em>obtiene</em> los valores a imprimir, a partir de utilizar la función <code class="docutils literal notranslate"><span class="pre">combinaciones()</span></code>.</p></li>
<li><p>Finalmente, <code class="docutils literal notranslate"><span class="pre">combinaciones()</span></code> se sirve de la función <code class="docutils literal notranslate"><span class="pre">factorial()</span></code>.</p></li>
</ol>
<p>El programa principal utiliza la función <code class="docutils literal notranslate"><span class="pre">combinaciones()</span></code>; por tanto, la definición de esta última debe preceder en el texto del programa al primero. Por la misma razón, la función <code class="docutils literal notranslate"><span class="pre">factorial()</span></code> debe aparecer antes que <code class="docutils literal notranslate"><span class="pre">combinaciones()</span></code>.</p>
</div>
<div class="section" id="traza-de-un-programa">
<h3>Traza de un programa<a class="headerlink" href="#traza-de-un-programa" title="Permalink to this headline">¶</a></h3>
<p>La ejecución de un programa en Python comienza en la primera línea del programa principal. A partir de ese punto se van ejecutando las sentencias siguiendo el orden secuencial por defecto, que puede ser alterado por las sentencias de control de flujo ya conocidas.</p>
<p>La presencia de las llamadas a función implica la modificación de ese orden por defecto.</p>
<p>Durante la ejecución de un programa, se van modificando los diferentes valores involucrados en la medida en que se van ejecutando las diferentes sentencias. Se puede hablar del <strong>hilo de ejecución</strong> a esta evolución de una sentencia a otra y los efectos producidos. Una forma de hacer evidente esta evolución es realizando la <strong>traza del programa</strong>.</p>
<p>La traza se puede ejecutar con lápiz y papel. Las herramientas de desarrollo, como <strong>Spyder</strong>, suelen tener incorporados <strong>depuradores</strong> del código (<strong>debuggers</strong>), que permiten también construir la traza. Existen también otras aplicaciones disponibles, como <a class="reference external" href="http://www.pythontutor.com/visualize.html#mode=edit">pythontutor</a>, que ayudan en este propósito.</p>
<p>En lo que sigue se muestran algunos momentos de la traza del ejemplo previo.</p>
<p><img alt="Traza.jpg" src="../../_images/traza.jpg" /></p>
<p><span class="xref myst">Traza Ejemplo Combinaciones</span></p>
<p>A partir del análisis de la traza del programa se puede entender el mecanismo de las llamadas a función:</p>
<ul class="simple">
<li><p>Cuando durante la evaluación de una sentencia aparece la <strong>invocación</strong> de una o varias funciones, la ejecución de la sentencia actual debe interrumpirse para ejecutar la(s) llamada(s) a la(s) función(es) involucrada(s). Si existen varias llamadas a la hora de evaluar una expresión, las llamadas se realizarán secuencialmente en el orden en que sea necesario y que se deriva del orden de evaluación de la expresión en que aparecen.</p></li>
<li><p>El proceso de llamada a la función consiste en los siguientes pasos:</p>
<ol class="simple">
<li><p>Interrumpir la evaluación de la sentencia que provoca la llamada.</p></li>
<li><p>A continuación, y con vistas a que el <strong>hilo de ejecución</strong> del programa continúe en la primera sentencia de la función invocada, los parámetros reales (si existieran) son determinados y resultan copiados en los parámetros formales. Como se ha visto, la relación entre parámetros reales y argumentos formales se puede realizar por posición, pero también utilizando el concepto de argumento con nombre, o una combinación de ambos.</p></li>
<li><p>Se ejecuta la función desde su primera sentencia. Dentro de la función, se pueden utilizar los <strong>identificadores</strong> de los parámetros formales, para acceder a los valores que han sido <em>pasados</em> desde el código que ha llamado a la función. También se pueden crear nuevos valores (<strong>variables locales</strong>) en la medida en que se requiera.</p></li>
<li><p>Cuando el <strong>hilo de ejecución</strong> llegue a una sentencia <code class="docutils literal notranslate"><span class="pre">return</span></code> o simplemente a la última sentencia ejecutable, la siguiente sentencia a ejecutar sería aquella que resultó <em>interrumpida</em> cuando se llamó a la función.</p></li>
<li><p>Si la función devuelve valores mediante la sentencia <code class="docutils literal notranslate"><span class="pre">return</span></code>, el valor <em>devuelto</em> participará en la expresión cuya evaluación fue interrumpida.</p></li>
</ol>
</li>
</ul>
<p>En el ejemplo:</p>
<ul class="simple">
<li><p>Durante la evaluación de los argumentos de la función nativa <code class="docutils literal notranslate"><span class="pre">print()</span></code>, se necesita llamar a la función <code class="docutils literal notranslate"><span class="pre">combinaciones()</span></code>, pasando como parámetros reales los valores <code class="docutils literal notranslate"><span class="pre">elementos</span></code> y <code class="docutils literal notranslate"><span class="pre">muestras</span></code>, que en este ejemplo identifican a los enteros <code class="docutils literal notranslate"><span class="pre">5</span></code> y <code class="docutils literal notranslate"><span class="pre">3</span></code> respectivamente. Los parámetros reales se asocian a los argumentos formales por posición: <code class="docutils literal notranslate"><span class="pre">5</span></code> <span class="math notranslate nohighlight">\(\Rightarrow\)</span> <code class="docutils literal notranslate"><span class="pre">n</span></code> y <code class="docutils literal notranslate"><span class="pre">3</span></code> <span class="math notranslate nohighlight">\(\Rightarrow\)</span> <code class="docutils literal notranslate"><span class="pre">k</span></code>.</p></li>
<li><p>Durante la evaluación de <code class="docutils literal notranslate"><span class="pre">combinaciones()</span></code> se llama a la función <code class="docutils literal notranslate"><span class="pre">factorial()</span></code>. Las llamadas se llevan a cabo en el orden en que evalúa la expresión en que aparecen:</p>
<ul>
<li><p>la primera vez con el parámetro formal dado por el contenido de la variable <code class="docutils literal notranslate"><span class="pre">n</span></code> de <code class="docutils literal notranslate"><span class="pre">combinaciones()</span></code> que se asocia por posición al argumento real <code class="docutils literal notranslate"><span class="pre">n</span></code> de <code class="docutils literal notranslate"><span class="pre">factorial()</span></code>.</p></li>
<li><p>la segunda vez con el parámetro real <code class="docutils literal notranslate"><span class="pre">k</span></code> que se asocia al parámetro formal <code class="docutils literal notranslate"><span class="pre">n</span></code> de <code class="docutils literal notranslate"><span class="pre">factorial()</span></code>.</p></li>
<li><p>la tercera vez con el parámetro real que es el resultado de la expresión <code class="docutils literal notranslate"><span class="pre">n-k</span></code> y que de nuevo se asocia al parámetro <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="la-pila-de-llamadas">
<h3>La pila de llamadas<a class="headerlink" href="#la-pila-de-llamadas" title="Permalink to this headline">¶</a></h3>
<p>¿Cuál es el mecanismo que soporta el funcionamiento correcto de las llamadas a funciones? ¿Cómo el intérprete de Python <em>conoce</em> el punto exacto al que se debe retornar cuando cada una de las llamadas a función termina retornando valores?</p>
<p>Como se refleja en la figura anterior, al inicio de cada llamada se crea un <strong>marco de memoria</strong> local de valores que contienen:</p>
<ul class="simple">
<li><p>los valores de entrada de los argumentos de la función</p></li>
<li><p>todas aquellas variables que la función declare localmente.</p></li>
</ul>
<p>El <strong>marco de memoria</strong> de la función estará vigente mientras el <strong>hilo de ejecución</strong> de la función se <em>encuentre</em> dentro de la mismas, es decir, mientras la función no haya finalizado.</p>
<p>Si la función llama a su vez a otra función (ej: cuando <code class="docutils literal notranslate"><span class="pre">combinaciones()</span></code> llama a <code class="docutils literal notranslate"><span class="pre">factorial()</span></code>) el <strong>marco</strong> asociado a la función que llama no desaparece, sino que se crea un nuevo <strong>marco</strong> asociado a la función llamada.</p>
<p>El mecanismo de creación de estos <strong>marcos</strong> en la memoria del ordenador sigue el esquema asociado a una estructura de datos muy conocida en programación que es la llamada <strong>pila</strong> (<strong>stack</strong>).</p>
<p><img alt="Pila.jpg" src="../../_images/pila.jpg" /></p>
<p>La pila almacena información, pero lo hace <strong>restringiendo</strong> la forma en que esta información puede ser añadida o eliminada.
Así, la pila tiene sólo dos operaciones básicas:</p>
<ul class="simple">
<li><p><strong>PUSH(dato)</strong>: Es la forma de introducir un nuevo dato en la pila y sólo puede hacerse por la parte <em>superior</em> de la misma, utilizando para ello el <strong>puntero de la pila</strong> (<strong>SP</strong>: <strong>stack pointer</strong>). El <strong>SP</strong> contiene la <em>dirección</em> en memoria del dato actualmente en la parte superior. Para introducir un nuevo dato, el <strong>SP</strong> debe ser incrementado (si es que hay memoria suficiente para hacerlo) para introducir el dato en la nueva localización de memoria, actualizando el valor <strong>SP</strong> que ahora <strong>apuntará</strong> al nuevo dato.</p></li>
</ul>
<blockquote>
<div><p>El método <code class="docutils literal notranslate"><span class="pre">append(dato)</span></code> de las listas es un ejemplo de la operación tipo <strong>PUSH(dato)</strong>.</p>
</div></blockquote>
<ul class="simple">
<li><p><strong>POP()</strong>: Para poder realizar esta operación, la <strong>pila</strong> no puede estar vacía: o sea, el <strong>SP</strong> no puede ser igual a la <strong>base de la pila</strong> (<strong>SB</strong>: <strong>stack bottom</strong>). Si no está vacía la pila, la operación <strong>POP</strong> simplemente consiste en <em>decrementar</em> el <strong>SP</strong>. El elemento que antes estaba en el <em>tope</em> ahora resulta inaccesible, con lo que a todos los efectos es como si ha resultado <strong>eliminado</strong>. Si acto seguido se vuelve a apilar, el nuevo dato se <strong>sobrescribirá</strong> sobre el anterior.</p></li>
</ul>
<blockquote>
<div><p>El método <code class="docutils literal notranslate"><span class="pre">pop()</span></code> de las listas, sin argumentos, es un ejemplo de la operación tipo <strong>POP()</strong>. Nótese que las listas no son una estructura de datos tipo pila, porque están permitidas operaciones como <code class="docutils literal notranslate"><span class="pre">remove()</span></code> o <code class="docutils literal notranslate"><span class="pre">insert()</span></code> que están prohibidas en una pila.</p>
</div></blockquote>
<p>Los <strong>marcos de variables</strong> que se crean para albergar las variables de cada función se implementan precisamente en una estructura de datos, la <strong>pila del sistema</strong> o <strong>pila de llamadas</strong>, que es independiente para cada <strong>hilo de ejecución</strong> que se encuentre en el ordenador. Esto es implementado conjuntamente por el <em>hardware</em> del computador, el Sistema Operativo y el <strong>motor en tiempo de ejecución</strong> (<strong>runtime engine</strong>) de Python.</p>
<p>El funcionamiento básico de las llamadas a funciones y de los <strong>marcos</strong> desde el punto de vista de la <strong>pila del sistema</strong> es el siguiente:</p>
<ul class="simple">
<li><p>Cuando se produce la llamada a la función, se realiza una operación <strong>PUSH</strong> introduciendo en la <strong>pila</strong> el nuevo <strong>marco</strong> necesario. Además de los parámetros de la función y las variables locales, también se introduce otro tipo de información no mostrada en los diagramas de trazas previos. La más importante es la <em>dirección</em> en memoria que marca el punto exacto donde se encuentra alojada la instrucción cuya evaluación ha sido interrumpida para llamar a la función y al que hay que regresar cuando la misma termine.</p></li>
<li><p>Cuando una función termina su ejecución, se realiza una operación <strong>POP</strong> de forma que los valores almacenados  quedan efectivamente <em>eliminados</em> de la memoria por inaccesibles. Antes de hacer la operación <strong>POP</strong>, se obtiene de la <strong>pila</strong> la dirección de retorno y valor que se va a devolver.</p></li>
<li><p>Observe que, durante las llamadas anidadas a distintas funciones, el especial funcionamiento de la <strong>pila</strong> permite adquirir y liberar la memoria de los <strong>marcos</strong> de la forma adecuada.</p></li>
</ul>
<hr class="docutils" />
<p><a id='Alcance_de_las_variables:_variables_locales_y_globales'></a></p>
</div>
</div>
<div class="section" id="alcance-de-las-variables-variables-locales-y-globales">
<h2>Alcance de las variables: variables locales y globales<a class="headerlink" href="#alcance-de-las-variables-variables-locales-y-globales" title="Permalink to this headline">¶</a></h2>
<p>El <strong>alcance</strong> de una variable da cuenta de las reglas que especifican <em>desde</em> qué sentencias del código Python son <em>accesibles</em> cada una de las variables, teniendo en cuenta el <em>lugar</em> dentro del código en el que han sido especificadas.</p>
<p>Como se ha visto, los parámetros formales en la definición de una función y las variables creadas en el cuerpo de la misma, son <strong>variables locales</strong> a dicha función y sólo pueden ser accedidas desde código definido en el cuerpo de la misma en sentencias posteriores a su creación.</p>
<p>La esencia de una <strong>buena programación</strong> procedural y modular, y de ello la gran ventaja del uso de las funciones, reside precisamente en el uso preferente de <strong>variables locales</strong>, puesto que este es el mecanismo del lenguaje que brinda el grado apropiado de <em>desacople</em> necesario entre el código que <em>usa</em> una función y su implementación interna. Esto es, garantiza la muy necesaria <em>abstracción</em> que hace que podamos utilizar las funciones sin preocuparnos de los <em>detalles</em> internos.</p>
<p>Obsérvese que esta independencia quedaría destruida si las variables internas, que se crean en el <strong>marco</strong> de la función, pudieran ser modificadas o accedidas externamente. De nuevo hay que recalcar que la interacción legítima con las funciones debe ser a partir de su interfaz pública: los argumentos formales y los valores de retorno.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Multiplica n * 10</span>
<span class="k">def</span> <span class="nf">mult_10</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">n</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;a en mult_10: &#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="s1">&#39;n en mult_10: &#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>


<span class="c1"># Programa principal</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">mult_10</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;a en prog. principal: &#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="s1">&#39;n en prog. principal: &#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>a en mult_10:  150 n en mult_10:  15
a en prog. principal:  5 n en prog. principal:  150
</pre></div>
</div>
</div>
</div>
<p>En el código previo, las variables <code class="docutils literal notranslate"><span class="pre">a</span></code> y <code class="docutils literal notranslate"><span class="pre">n</span></code> creadas en el programa principal, no son las mismas que las variables con idéntico nombre en la función <code class="docutils literal notranslate"><span class="pre">mult_10()</span></code>. Estas últimas están definidas en el <strong>marco</strong> local de la función: la primera <code class="docutils literal notranslate"><span class="pre">n</span></code> es el nombre del argumento formal de la función y la segunda es creada cuando se realiza la asignación (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">10*n</span></code>). De hecho, debe notarse que al llamar a la función, lo que se pasa como parámetro real a la misma, es el resultado de multiplicar <code class="docutils literal notranslate"><span class="pre">3*a</span></code>. Finalmente, cuando la función retorna, es el valor de la variable local <code class="docutils literal notranslate"><span class="pre">a</span></code> el que resulta asignado a la variable <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p>Este grado de desconexión entre las variables locales de la diferentes funciones y las del programa principal es precisamente lo que se busca.</p>
<p>De todas formas, en Python se considera que las funciones están definidas <strong>dentro</strong> del programa principal. Siendo este el caso, es cierto que desde la función se puede <strong>acceder</strong> a variables definidas en el programa principal, siempre que no haya ningún parámetro o variable local del mismo nombre.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;func a = &#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="s1">&#39;b = &#39;</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="s1">&#39;c = &#39;</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

    
<span class="c1"># Programa principal</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">c</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Prog. principal a = &#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="s1">&#39;b = &#39;</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="s1">&#39;c = &#39;</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>func a =  5 b =  1 c =  30
Prog. principal a =  5 b =  10 c =  20
</pre></div>
</div>
</div>
</div>
<p>Se observa que desde la función se puede leer la variable <code class="docutils literal notranslate"><span class="pre">a</span></code> utilizada en el programa principal. Y que la única razón de que no se pueda acceder a las variables <code class="docutils literal notranslate"><span class="pre">b</span></code> y <code class="docutils literal notranslate"><span class="pre">c</span></code> también del programa principal, es que existen parámetros formales (<code class="docutils literal notranslate"><span class="pre">b</span></code>) y variables locales (<code class="docutils literal notranslate"><span class="pre">c</span></code>) del mismo nombre.</p>
<p>Este ejemplo que acabamos de ver es una muestra de <strong>pésima programación</strong>, pues perdemos el <strong>encapsulamiento</strong> del código y la <strong>mantenibilidad</strong> del código se hace imposible.</p>
<div class="section" id="jerarquia-de-acceso-a-los-nombres">
<h3>Jerarquía de acceso a los nombres<a class="headerlink" href="#jerarquia-de-acceso-a-los-nombres" title="Permalink to this headline">¶</a></h3>
<p>En Python se cumple una jerarquía de acceso a los nombres que se evidencia en el siguiente esquema.</p>
<p><img alt="Venn.jpg" src="../../_images/venn.jpg" /></p>
<p>Esto es: si se produce una referencia a una variable de nombre dado en la función <code class="docutils literal notranslate"><span class="pre">f()</span></code>, Python determinará a qué objeto hace referencia, en el sentido en que se muestra en el esquema anterior:</p>
<ul class="simple">
<li><p>primero comprobará si existe una variable local de <code class="docutils literal notranslate"><span class="pre">f()</span></code> con ese nombre</p></li>
<li><p>en caso de fallar, entonces se verá si se trata de un parámetro formal</p></li>
<li><p>si no lo es, se mirará si es una variable del programa principal, variables a las que podemos calificar de <strong>globales</strong>.</p></li>
<li><p>y finalmente si esto también falla, se intentará encontrar un objeto de ese nombre entre los definidos intrínsecamente (<em>built_in</em>) en el lenguaje</p></li>
<li><p>si también esto falla, se producirá un error de tiempo de ejecución.</p></li>
</ul>
<p>Nótese que en la cadena descrita de búsqueda por la variable a la que se hace referencia, no se menciona a la función <code class="docutils literal notranslate"><span class="pre">g()</span></code> que estaría definida al mismo <em>nivel</em> que <code class="docutils literal notranslate"><span class="pre">f()</span></code> y por tanto no participaría en la búsqueda de los nombres de esta función <code class="docutils literal notranslate"><span class="pre">f()</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">():</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;func a = &#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

    
<span class="c1"># Programa principal</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">func</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Prog. principal a = &#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>func a =  30
Prog. principal a =  5
</pre></div>
</div>
</div>
</div>
<p>En el código previo, se intenta modificar dentro de la función <code class="docutils literal notranslate"><span class="pre">fun()</span></code> la <strong>variable global</strong> <code class="docutils literal notranslate"><span class="pre">a</span></code> creada en el programa principal. ¡Pero comprobarás que el efecto no es el pretendido!</p>
<p>¿Qué ha sucedido?</p>
<p>Tal y como hemos visto, en la línea 2, Python <strong>crea</strong> de forma transparente al usuario una nueva variable con el mismo nombre pero local a <code class="docutils literal notranslate"><span class="pre">func()</span></code>. Por lo que, si la intención del programador era modificar la variable global <code class="docutils literal notranslate"><span class="pre">a</span></code>, no lo ha conseguido.</p>
<p>Normalmente, no se debe <strong>acceder</strong> a variables globales desde dentro de las funciones: no es buena idea <strong>leer</strong> el valor de dichas variables, pero mucho menos <strong>modificarlas</strong> mediante una asignación. Un código en el que desde diferentes funciones, se modifiquen variables globales es un programa de difícil mantenimiento y depuración.</p>
<p>Si existiera la necesidad puntual de modificar la variable global, en el ejemplo, ¿Hay alguna forma?</p>
<p>La respuesta es que sí. Para ello hay que declarar dentro de la función la variable en cuestión como <code class="docutils literal notranslate"><span class="pre">global</span></code>. El siguiente código muestra cómo hacerlo.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># No hagas esto nunca</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">a</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;func a = &#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

    
<span class="c1"># Programa principal</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">func</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Prog. principal a = &#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>func a =  30
Prog. principal a =  30
</pre></div>
</div>
</div>
</div>
<p>Se debe insistir en que se debe evitar a toda costa el uso de variables globales. Basta cambiar el identificador <code class="docutils literal notranslate"><span class="pre">a</span></code> por <code class="docutils literal notranslate"><span class="pre">b</span></code> en el programa principal del ejemplo anterior para que la salida del programa sea totalmente diferente.</p>
<p><strong>¡Durante el curso queda terminantemente prohibido el uso de variables globales dentro de una función!</strong></p>
</div>
<div class="section" id="parametros-de-una-funcion-mutables">
<h3>Parámetros de una función mutables<a class="headerlink" href="#parametros-de-una-funcion-mutables" title="Permalink to this headline">¶</a></h3>
<p>¿Es posible alterar valores externos a la función por otro método que no sea mediante el desaconsejado uso de variables globales?</p>
<p>La respuesta es que esto depende de si el parámetro es <strong>mutable</strong> o <strong>inmutable</strong></p>
<blockquote>
<div><p>Un parámetro mutable, como una lista, cuando es modificado en la función, altera el objeto original en el código que realizó la llamada a función.</p>
</div></blockquote>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Ejemplo que muestra implicaciones alcance local</span>
<span class="k">def</span> <span class="nf">mult_val_int</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>  <span class="c1"># El objeto v es el mismo que el objeto val</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">*</span><span class="n">n</span>  
    <span class="nb">print</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>  <span class="c1"># Debido a la inmutabilidad, ahora v es otro objeto</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>


<span class="c1"># Programa principal</span>
<span class="n">val</span> <span class="o">=</span> <span class="mi">2</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">mult_val_int</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>140733118652848
140733118652848
140733118652976
6
2
</pre></div>
</div>
</div>
</div>
<p>En el ejemplo anterior, vía la función <code class="docutils literal notranslate"><span class="pre">id()</span></code>, podemos ver que el objeto <code class="docutils literal notranslate"><span class="pre">val</span></code> del programa principal y el parámetro formal <code class="docutils literal notranslate"><span class="pre">v</span></code> son el mismo objeto. Sin embargo, cuando en el código de la función <code class="docutils literal notranslate"><span class="pre">mult_val_int()</span></code> se modifica el valor del parámetro formal <code class="docutils literal notranslate"><span class="pre">v</span></code> en la línea <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">v*n</span></code>, como se trata de una variable entera y, por tanto, <strong>inmutable</strong>, lo que hace Python es <strong>crear</strong> un nuevo objeto, en este caso <strong>local</strong> a la función, y asignarle el nombre de <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<p>Cuando el <strong>hilo de ejecución</strong> del programa abandona la función, el marco local es eliminado, y el valor del objeto <code class="docutils literal notranslate"><span class="pre">val</span></code> definido en el <strong>programa principal</strong> permanece inalterado.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Ejemplo que muestra implicaciones de alcance global</span>
<span class="k">def</span> <span class="nf">mult_2_lista</span><span class="p">(</span><span class="n">lista</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">lista</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lista</span><span class="p">)):</span>
        <span class="n">lista</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">lista</span><span class="p">))</span>


<span class="c1"># Programa principal</span>
<span class="n">lista_pp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">lista_pp</span><span class="p">))</span>
<span class="n">mult_2_lista</span><span class="p">(</span><span class="n">lista_pp</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;En programa principal:&quot;</span><span class="p">,</span> <span class="n">lista_pp</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2609511315144
2609511315144
2609511315144
En programa principal: [2, 4, 6]
</pre></div>
</div>
</div>
</div>
<p>En el ejemplo previo, el argumento a la función <code class="docutils literal notranslate"><span class="pre">mult_2_lista()</span></code> es un valor de tipo <strong>mutable</strong>, la lista, y esto marca toda la diferencia. La función recibe mediante su argumento formal, una referencia a la lista inicializada (el parámetro real) definida en el programa principal. Dentro de la función, se modifican todos los elementos de la lista, multiplicándolos por 2. Como se trata de un dato <strong>mutable</strong>, no se crea un nuevo objeto sino que <strong>se modifican</strong> sus valores originales.</p>
<p><img alt="TrazaModLista.jpg" src="../../_images/traza_modificacion_lista.jpg" /></p>
<p>Ya hemos visto ejemplos con los métodos de las listas, tales como  <code class="docutils literal notranslate"><span class="pre">pop()</span></code>, <code class="docutils literal notranslate"><span class="pre">insert()</span></code>, <code class="docutils literal notranslate"><span class="pre">remove()</span></code>, etc. cómo podemos alterar objetos a través de una función. La diferencia substancial a hacerlo así respecto al uso de <code class="docutils literal notranslate"><span class="pre">global</span></code>, es:</p>
<ul class="simple">
<li><p>a través del nombre del método, <em>manifestamos</em> explícitamente el hecho de que vamos a alterar de una forma determinada la variable.</p></li>
<li><p>si altero el nombre de la variable global, <code class="docutils literal notranslate"><span class="pre">lista_pp</span></code> en el ejemplo anterior, el comportamiento del programa no varía.</p></li>
</ul>
<hr class="docutils" />
<p><a id='Recursividad'></a></p>
</div>
</div>
<div class="section" id="recursividad">
<h2>Recursividad<a class="headerlink" href="#recursividad" title="Permalink to this headline">¶</a></h2>
<p>El lenguaje Python permite que las funciones puedan llamarse a sí mismas y a esto se le llama <strong>recursividad</strong>.</p>
<p>Veamos el siguiente ejemplo sencillo. Se trata de un programa que realiza un conteo descendente desde el valor entero que se le pasa como parámetro hasta cero.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Cuenta atrás utilizando recursividad</span>
<span class="k">def</span> <span class="nf">cuenta_atras</span><span class="p">(</span><span class="n">cont</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">cont</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span> <span class="s1">&#39;Lanzando....&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span> <span class="s1">&#39;....&#39;</span><span class="p">)</span>
        <span class="n">cuenta_atras</span><span class="p">(</span><span class="n">cont</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>


<span class="c1"># Programa principal</span>
<span class="n">cuenta_atras</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>10 ....
9 ....
8 ....
7 ....
6 ....
5 ....
4 ....
3 ....
2 ....
1 ....
0 Lanzando....
</pre></div>
</div>
</div>
</div>
<p>A notar:</p>
<ol class="simple">
<li><p>La solución recursiva carece de bucles.</p></li>
<li><p>El mismo efecto se podría haber logrado con bucles: cualquier solución recursiva admite una implementación iterativa (y viceversa).</p></li>
<li><p>El condicional <code class="docutils literal notranslate"><span class="pre">if</span></code> es clave en la implementación de la recursividad. Permite distinguir los dos casos que siempre deben estar presentes en una función recursiva útil:</p>
<ul class="simple">
<li><p><strong>el caso base</strong>: que permite finalizar la función y devolver el control al código que la llamó: en este caso la condición de que <code class="docutils literal notranslate"><span class="pre">cont</span> <span class="pre">&lt;</span> <span class="pre">1</span></code>.</p></li>
<li><p><strong>la llamada recursiva</strong>: en la cual se realiza la llamada a la propia función que se define (en el ejemplo <code class="docutils literal notranslate"><span class="pre">cuenta_atras()</span></code>) pasando un argumento diferente que logre el propósito de que la ejecución sucesiva de la función se acerque al caso base, esto es, a la condición de finalización de la función.</p></li>
</ul>
</li>
</ol>
<div class="section" id="por-que-funciona-la-recursividad">
<h3>¿Por qué funciona la recursividad?<a class="headerlink" href="#por-que-funciona-la-recursividad" title="Permalink to this headline">¶</a></h3>
<p>La clave para entenderlo está en el mecanismo ya discutido de la llamada a las funciones. Específicamente en el hecho de que, para cada nueva llamada recursiva a la función, se crea un nuevo marco local dónde se definen los parámetros y variables locales, logrando de esa forma que no se sobrescriban los datos perteneciente a la invocación anterior de la misma función.</p>
</div>
<div class="section" id="desventajas-de-una-funcion-recursiva-con-respecto-a-la-iterativa">
<h3>Desventajas de una función recursiva con respecto a la iterativa<a class="headerlink" href="#desventajas-de-una-funcion-recursiva-con-respecto-a-la-iterativa" title="Permalink to this headline">¶</a></h3>
<p>En el ejemplo sencillo visto no se gana nada con la implementación recursiva.</p>
<ul class="simple">
<li><p>Requiere mayor cantidad de memoria y esa cantidad de memoria extra crece con el número de llamadas recursivas (con el tamaño del problema). La memoria extra se requiere para definir los diversos marcos locales de memoria</p></li>
<li><p>La ejecución es más lenta: las llamadas a funciones añaden tiempo de cómputo: mayor número de instrucciones en código de máquina necesarias para crear los nuevos marcos de memoria, copiar los parámetros, <em>recordar</em> la dirección de retorno necesaria cuando la función retorna, etc.</p></li>
</ul>
</div>
<div class="section" id="cual-es-entonces-la-utilidad-de-una-solucion-recursiva">
<h3>¿Cuál es, entonces, la utilidad de una solución recursiva?<a class="headerlink" href="#cual-es-entonces-la-utilidad-de-una-solucion-recursiva" title="Permalink to this headline">¶</a></h3>
<p>Hay una serie de problemas cuya propia definición hace que resulte muy natural el uso de una implementación recursiva. Este es caso del cálculo del factorial (cuya implementación iterativa hemos utilizado antes), que puede ser definido, de forma muy intuitiva, como sigue:</p>
<p>\begin{equation}
n!=\begin{cases}
1 &amp; \text{si <span class="math notranslate nohighlight">\(n&lt;2\)</span>}.\
n(n-1)! &amp; \text{en caso contrario}.
\end{cases}
\end{equation}</p>
<p>En este caso, la solución iterativa y la recursiva resultan igual de sencillas. Hay otros casos, sin embargo, en que la solución recursiva resulta mucho más clara y natural. Es el caso de algunos métodos de ordenación eficientes, como QuickSort o MergeSort, el recorrido de estructuras de memoria como los árboles, retos curiosos como el problema de las Torres de Hanoi, etc.</p>
<p>Debido a sus valores didácticos, veremos en detalle la implementación recursiva del factorial.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Halla factorial de entero de forma recursiva</span>
<span class="k">def</span> <span class="nf">factr</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">*</span><span class="n">factr</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>


<span class="c1"># programa principal</span>
<span class="n">f_4</span> <span class="o">=</span> <span class="n">factr</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f_4</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>24
</pre></div>
</div>
</div>
</div>
<hr class="docutils" />
<p><a id='Las_funciones_como_objetos'></a></p>
</div>
</div>
<div class="section" id="las-funciones-como-objetos">
<h2>Las funciones como objetos<a class="headerlink" href="#las-funciones-como-objetos" title="Permalink to this headline">¶</a></h2>
<p>En Python, las funciones son consideradas como objetos: encapsulan datos y comportamiento. Habrá notado al discutir la traza de los programas previos que, junto a las variables <em>convencionales</em> del programa principal, aparecían también referencias a las funciones definidas en el programa como si fueran otras tantas variables. Esto se hace porque, de hecho, las funciones son también consideradas como un tipo especial de objeto.</p>
<p>Esta consideración tiene implicaciones muy interesantes. Quizá la más notable es que se pueden <em>pasar</em> funciones como parámetros a otras, creando, por así decirlo, funciones de orden superior y brindando una gran flexibilidad a la programación.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Limita valor de argumento entre [inf,sup]</span>
<span class="k">def</span> <span class="nf">limita</span><span class="p">(</span><span class="n">valor</span><span class="p">,</span> <span class="n">inf</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">sup</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">inf</span> <span class="o">&lt;=</span> <span class="n">valor</span> <span class="o">&lt;=</span> <span class="n">sup</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">valor</span>
    <span class="k">elif</span> <span class="n">valor</span> <span class="o">&gt;</span> <span class="n">sup</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sup</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">inf</span>


<span class="c1"># multiplica parámetro por 2</span>
<span class="k">def</span> <span class="nf">mult_2</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">*=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">n</span>


<span class="c1"># Recibe lista y aplica func() a cada uno de los elementos</span>
<span class="k">def</span> <span class="nf">procesa_lista</span><span class="p">(</span><span class="n">lista</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lista</span><span class="p">)):</span>
        <span class="n">lista</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">lista</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>


<span class="c1"># Programa principal</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.1</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>
<span class="n">procesa_lista</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">limita</span><span class="p">)</span>
<span class="n">procesa_lista</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mult_2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[2.0, 1.4, 0.2]
</pre></div>
</div>
</div>
</div>
<p>Las dos primeras funciones definidas en el código previo (<code class="docutils literal notranslate"><span class="pre">limita()</span></code> y <code class="docutils literal notranslate"><span class="pre">mult_2()</span></code>) reciben como parámetro formal un valor de tipo numérico y devuelven mediante <code class="docutils literal notranslate"><span class="pre">return</span></code> otro valor. En el primer caso, se trata de una función ya vista, que <em>limita</em> el valor de entrada a un rango especificado por otros dos parámetros, mientras que, en el segundo caso, se devuelve el valor de entrada, multiplicado por 2.
Por su parte, la función <code class="docutils literal notranslate"><span class="pre">procesa_lista()</span></code> recibe como primer parámetro una lista. Lo novedoso es que el segundo parámetro, <code class="docutils literal notranslate"><span class="pre">func</span></code>, es un <strong>objeto de tipo función</strong>, utilizado para modificar cada uno de los elementos de la lista recibida.</p>
<p>En el programa principal, la función de orden superior <code class="docutils literal notranslate"><span class="pre">procesa_lista()</span></code> es invocada dos veces, para realizar dos procesamientos completamente diferentes. Esto se logra pasando en cada caso, como segundo parámetro, una función diferente, primero <code class="docutils literal notranslate"><span class="pre">limita()</span></code> y después <code class="docutils literal notranslate"><span class="pre">mult_2()</span></code>. El primero para limitar cada uno de los elementos de la lista a un rango entre <code class="docutils literal notranslate"><span class="pre">[0,1]</span></code> y el segundo para multiplicar la lista resultante por <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p>
<div class="section" id="haciendo-que-una-funcion-sea-pura">
<h3>Haciendo que una función sea pura<a class="headerlink" href="#haciendo-que-una-funcion-sea-pura" title="Permalink to this headline">¶</a></h3>
<p>Debe notarse que la función <code class="docutils literal notranslate"><span class="pre">procesa_lista()</span></code> tiene un comportamiento que puede ser indeseable. Altera el valor de la lista original del programa principal, como consecuencia de la mutabilidad de las listas.</p>
<p>Puede que un usuario necesite preservar la lista original. Una opción es hacer una copia con anterioridad. La otra es utilizar una versión <strong>pura</strong>, sin <strong>efectos colaterales</strong> (<strong>side effects</strong>) que <em>sorprendan</em> al usuario.</p>
<p>Veamos una versión pura:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Recibe lista y aplica func() a cada uno de los elementos grabándo el resultado en una nueva lista</span>
<span class="k">def</span> <span class="nf">procesa_lista_pura</span><span class="p">(</span><span class="n">lista</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
    <span class="n">nueva_lista</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lista</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lista</span><span class="p">)):</span>
        <span class="n">nueva_lista</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">lista</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">nueva_lista</span>


<span class="c1"># Programa principal</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.1</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">procesa_lista_pura</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">limita</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">procesa_lista_pura</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">mult_2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[2.0, 1.4, 0.2]
</pre></div>
</div>
</div>
</div>
<hr class="docutils" />
<p><a id='Funciones_con_un_número_indeterminado_de_argumentos'></a></p>
</div>
</div>
<div class="section" id="funciones-con-un-numero-indeterminado-de-argumentos">
<h2>Funciones con un número indeterminado de argumentos<a class="headerlink" href="#funciones-con-un-numero-indeterminado-de-argumentos" title="Permalink to this headline">¶</a></h2>
<p>En la versión original del código de <code class="docutils literal notranslate"><span class="pre">procesa_lista_pura()</span></code> no se pueden utilizar funciones que a su vez utilicen otros argumentos de entrada. Así, la función <code class="docutils literal notranslate"><span class="pre">limita(valor,</span> <span class="pre">inf=0,</span> <span class="pre">sup=1)</span></code> cumple su cometido pero siempre que se utilicen los valores por defecto de los argumentos formales <code class="docutils literal notranslate"><span class="pre">inf</span></code> y <code class="docutils literal notranslate"><span class="pre">sup</span></code>, <code class="docutils literal notranslate"><span class="pre">0</span></code> y <code class="docutils literal notranslate"><span class="pre">1</span></code> respectivamente.</p>
<p>¿Cómo poder pasar a la función de orden superior <code class="docutils literal notranslate"><span class="pre">procesa_lista_pura()</span></code> además del nombre de la función a aplicar, los parámetros que esta última pudiera tener?</p>
<p>Para hacerlo se puede hacer uso de la posibilidad que brinda Python de definir funciones con un número variable de argumentos.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">procesa_lista_pura</span><span class="p">(</span><span class="n">lista</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
</pre></div>
</div>
<p>Con la declaración previa se está informando de que la función en cuestión siempre va a recibir dos argumentos, <code class="docutils literal notranslate"><span class="pre">lista</span></code> y <code class="docutils literal notranslate"><span class="pre">func</span></code>, pero que a continuación puede recibir de cero hasta un número arbitrariamente grande de parámetros representados por <code class="docutils literal notranslate"><span class="pre">*arg</span></code>.</p>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">arg</span></code> no es sino una tupla formada a partir de los argumentos opcionales. El operador unario <code class="docutils literal notranslate"><span class="pre">*</span></code> actúa de desempaquetador de la tupla para generar una lista de argumentos.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">limita</span><span class="p">(</span><span class="n">valor</span><span class="p">,</span> <span class="n">inf</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">sup</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">inf</span> <span class="o">&lt;=</span> <span class="n">valor</span> <span class="o">&lt;=</span> <span class="n">sup</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">valor</span>
    <span class="k">elif</span> <span class="n">valor</span> <span class="o">&gt;</span> <span class="n">sup</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sup</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">inf</span>


<span class="c1"># Recibe lista y aplica func() a cada uno de los elementos</span>
<span class="k">def</span> <span class="nf">procesa_lista_pura</span><span class="p">(</span><span class="n">lista</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">):</span>
    <span class="n">nueva_lista</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lista</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lista</span><span class="p">)):</span>
        <span class="n">nueva_lista</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">lista</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nueva_lista</span>


<span class="c1"># Programa principal</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.1</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">4.1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.5</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">procesa_lista_pura</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">limita</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[2, 0.7, 0.1, 2, 2, 0]
</pre></div>
</div>
</div>
</div>
<p>En el cuerpo de la función, al invocar a la función <code class="docutils literal notranslate"><span class="pre">func()</span></code> se la pasan los mismos argumentos <code class="docutils literal notranslate"><span class="pre">*arg</span></code> que ha recibido.</p>
<p>En el programa principal, la lista de argumentos para este caso concreto se reduce a dos, los límites inferior y superior.</p>
<p>El número variable de argumentos se puede utilizar en muchos otros contextos. Analice el ejemplo que aparece a continuación.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">suma</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>  <span class="c1"># arg es una tupla formada por los parámetros</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="n">elem</span>
    <span class="k">return</span> <span class="nb">sum</span>


<span class="nb">print</span><span class="p">(</span><span class="n">suma</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">suma</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>

<span class="n">lista</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">suma</span><span class="p">(</span><span class="o">*</span><span class="n">lista</span><span class="p">))</span>  <span class="c1"># *lista desempaqueta la lista para enviar suma(1, 2, 3, 4, 5)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(1, 2, 3)
6
(4, 5, 6, 7)
22
(1, 2, 3, 4, 5)
15
</pre></div>
</div>
</div>
</div>
<p><a id='Polimorfismo_con_funciones'></a></p>
</div>
<div class="section" id="polimorfismo-con-funciones">
<h2>Polimorfismo con funciones<a class="headerlink" href="#polimorfismo-con-funciones" title="Permalink to this headline">¶</a></h2>
<p>A diferencia de otros muchos lenguajes, Python no exige la declaración previa del <strong>tipo</strong> de los datos a utilizar, sino que estos son determinados <strong>dinámicamente</strong> en el momento en que se utilizan (<strong><em>tipado dinámico</em></strong>).</p>
<p>Por otra parte, como también se ha visto, los operadores en Python, están <strong>sobrecargados</strong>.</p>
<blockquote>
<div><p>Por ejemplo, el operador <code class="docutils literal notranslate"><span class="pre">+</span></code> está definido para sumar tipos numéricos <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code> y <code class="docutils literal notranslate"><span class="pre">complex</span></code>, con la interpretación <em>natural</em> derivada de las matemáticas. Pero también puede ser utilizado con <code class="docutils literal notranslate"><span class="pre">list</span></code> y <code class="docutils literal notranslate"><span class="pre">str</span></code> con un significado de <strong>concatenación</strong>.</p>
</div></blockquote>
<p>El <strong>tipado dinámico</strong> y la <strong>sobrecarga</strong> de los operadores hacen que las funciones en Python tengan un comportamiento <strong>polimórfico</strong>: la capacidad que tiene una misma función de poder operar con diferentes tipos de datos y ofrecer un resultado coherente, compatible con el propósito de la función, pero adaptado a cada caso particular.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Función que suma dos valores de entrada</span>
<span class="k">def</span> <span class="nf">suma</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span>


<span class="c1"># Programa Principal que ilustra uso polimórfico de la función suma</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sumando enteros:&#39;</span><span class="p">,</span> <span class="n">suma</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sumando floats:&#39;</span><span class="p">,</span> <span class="n">suma</span><span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Concatenando lista (con función suma):&#39;</span><span class="p">,</span> <span class="n">suma</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Sumando enteros: 5
Sumando floats: 6.5
Concatenando lista (con función suma): [1, 2, 3, 5]
</pre></div>
</div>
</div>
</div>
<p>El hecho de que el operador <code class="docutils literal notranslate"><span class="pre">+</span></code> esté sobrecargado, que Python no <em>exija</em> la declaración previa del tipo de las variables y, por supuesto, tampoco del tipo de los parámetros formales de una función, hace que éstas se comporten de forma polimórfica.</p>
<p>Un ejemplo algo más complejo:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Recibe dos tipos iterables (lista, tuplas, cadenas ...) y devuelve</span>
<span class="c1"># una lista con los elementos del primer argumento no contenidos en el segundo</span>
<span class="k">def</span> <span class="nf">dif_iterables</span><span class="p">(</span><span class="n">iter1</span><span class="p">,</span> <span class="n">iter2</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">diferencia</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">iter1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">elem</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">iter2</span><span class="p">:</span>
                <span class="n">diferencia</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span>
    <span class="k">return</span> <span class="n">diferencia</span>


<span class="c1"># Programa principal: probamos la función con diferentes tipos (siempre que puedan ser iterados)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Con listas -&gt;&quot;</span><span class="p">,</span> <span class="n">dif_iterables</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Con cadenas -&gt;&quot;</span><span class="p">,</span> <span class="n">dif_iterables</span><span class="p">(</span><span class="s2">&quot;123&quot;</span><span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Con tuplas -&gt;&quot;</span><span class="p">,</span> <span class="n">dif_iterables</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Con listas -&gt; [1, 2]
Con cadenas -&gt; [&#39;1&#39;, &#39;2&#39;]
Con tuplas -&gt; [1, 2]
</pre></div>
</div>
</div>
</div>
<p>La función en el ejemplo previo actúa de forma polimórfica cuando sus argumentos son dos colecciones <em>iterables</em>, devolviendo siempre una lista con aquellos elementos de la primera colección que no se encuentren en la segunda. En teoría de conjuntos se diría que es la operación <em>diferencia(A - B)</em>, donde tanto A como B son conjuntos.</p>
<p>¿Esto significa que se puede procesar correctamente cualquier tipo de datos de entrada? ¿Qué pasaría si es llamada con un parámetro que no sea una colección?</p>
<p>Evidentemente, en este caso utilizamos la estrategia <strong>EAFP</strong> con manejo de excepciones, para <em>lanzar</em> una excepción de tipo <strong>TypeError</strong> cuando se reciban valores no iterables, dejando que la función que la llame se <em>ocupe</em> de lidiar de forma <em>razonable</em> con el error.</p>
<div class="section" id="utilizando-introspeccion">
<h3>Utilizando introspección<a class="headerlink" href="#utilizando-introspeccion" title="Permalink to this headline">¶</a></h3>
<p>Un tópico de alguna manera relacionado con lo anterior, es el uso de las capacidades de <strong>introspección</strong> de lenguaje. Como Python tiene un <strong>tipado dinámico</strong>, tiene sentido que también se pueda <em>inspeccionar</em>,  <em>conocer</em> información relativa a las características de los valores utilizados durante la <strong>ejecución</strong> del programa.</p>
<p>Siguiendo con el ejemplo previo, hemos visto que con independencia del tipo de colección de que se trate, siempre se devuelve una lista. Este comportamiento puede ser el adecuado en muchos casos.</p>
<p>Pero ¿cómo hacer para que la función devuelva el mismo tipo de la colección que recibe como primer argumento. Esto es, si recibe una lista devuelve una lista y si recibe una tupla pues devuelve una tupla.</p>
<p>La modificación del código visto, que se ofrece en la siguiente celda, usa la función <code class="docutils literal notranslate"><span class="pre">isinstance()</span></code> para conocer en <strong>tiempo de ejecución</strong> el tipo del dato y, entonces, decidir si convertir la lista que actúa como variable local, a uno u otro tipo de dato.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Recibe dos tipos iterables (lista, tuplas, cadenas ...) y devuelve</span>
<span class="c1"># un iterable del mismo tipo con los elementos del primer argumento no contenidos en el segundo</span>
<span class="k">def</span> <span class="nf">dif_iterables2</span><span class="p">(</span><span class="n">iter1</span><span class="p">,</span> <span class="n">iter2</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">diferencia</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">iter1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">elem</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">iter2</span><span class="p">:</span>
                <span class="n">diferencia</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iter1</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">diferencia</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">diferencia</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iter1</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">diferencia</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">diferencia</span><span class="p">])</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span>
    <span class="k">return</span> <span class="n">diferencia</span>


<span class="c1"># Programa principal: probamos la función con diferentes tipos (siempre que puedar ser iterados)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Con listas&quot;</span><span class="p">,</span> <span class="n">dif_iterables2</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">3</span><span class="p">]]))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Con cadenas&quot;</span><span class="p">,</span> <span class="n">dif_iterables2</span><span class="p">(</span><span class="s2">&quot;12334&quot;</span><span class="p">,</span> <span class="s2">&quot;13&quot;</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Con tuplas&quot;</span><span class="p">,</span> <span class="n">dif_iterables2</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Con listas [1, [2]]
Con cadenas 24
Con tuplas (1, 2)
</pre></div>
</div>
</div>
</div>
<p>En el caso de la cadena, se convierten uno a uno los caracteres, utilizando la posibilidad de <strong>comprensión</strong> de las listas. El uso simplemente de <code class="docutils literal notranslate"><span class="pre">str(diferencia)</span></code> no da el resultado buscado, puesto que convertiría a <code class="docutils literal notranslate"><span class="pre">str</span></code>. Pero estos detalles, que variarán de ejemplo a ejemplo, no es lo importante del código, sino la posibilidad de <strong>adaptar</strong> el comportamiento de la función al tipo de datos concreto mediante la <strong>introspección</strong>.</p>
<hr class="docutils" />
<p><a id='Buenas_prácticas'></a></p>
</div>
</div>
<div class="section" id="buenas-practicas-en-el-diseno-de-funciones">
<h2>Buenas prácticas en el diseño de funciones<a class="headerlink" href="#buenas-practicas-en-el-diseno-de-funciones" title="Permalink to this headline">¶</a></h2>
<p>A partir del conocimiento adquirido en este tema, vamos a revisitar rápidamente, a modo de resumen, cuáles se consideran las <em>mejores prácticas</em> a la hora de diseñar nuestras <strong>funciones</strong> y, en definitiva, al estructurar el código del programa:</p>
<ul class="simple">
<li><p>Las funciones deben dedicarse a una sola tarea: en la literatura a esta característica se la llama <strong>principio de responsabilidad única</strong>.</p></li>
<li><p>La relación entre una función y otras, y entre éstas y el programa principal, debe realizarse, en la medida de lo posible, a través de la interfaz que ofrecen los parámetros de entrada y los valores devueltos mediante <code class="docutils literal notranslate"><span class="pre">return</span></code>. Esto es, el <strong>acoplamiento</strong> entre las funciones debe ser mínimo y producirse a través del mecanismo descrito. El <strong>acoplamiento</strong> sólo a través de la interfaz, garantiza el <strong>encapsulamiento</strong> que ofrecen las funciones: no interesa <strong>cómo</strong> está <em>implementada</em> la tarea a resolver, sino saber <strong>qué</strong> necesita y <strong>qué</strong> devuelve.
Esto implica:</p>
<ul>
<li><p>No usar variables globales (salvo en casos excepcionales).</p></li>
<li><p>No modificar, por sistema, los parámetros de la función que sean <strong>mutables</strong> (<strong>listas</strong>, <strong>diccionarios</strong>, <strong>sets</strong>). En los casos en que se decida hacerlo, documentar este hecho exhaustivamente.</p></li>
</ul>
</li>
<li><p>Una función <strong>no debe ocupar muchas líneas de código</strong>. Cuando <em>veamos</em> que el código de nuestra función <em>crece</em> demasiado, debemos plantearnos que <em>algo va mal</em> en el diseño de nuestro programa: se puede estar violando, por ejemplo, el <strong>principio de responsabilidad única</strong></p></li>
<li><p>Se debe intentar que nuestras funciones sean los más <strong>generales</strong> que sea posible: no tener diferentes funciones para elevar al cuadrado, al cubo, etc.</p></li>
<li><p>El hecho de que Python sea un lenguaje <strong>tipado dinámicamente</strong> hace que las funciones puedan ser <strong>polimórficas</strong>. Esto aumenta la responsabilidad del programador:</p>
<ul>
<li><p>Puede ser una ventaja porque hace que sean más <strong>generales</strong>; pero hay que tener en cuenta que debe funcionar correctamente para todos los tipos de datos que <em>razonablemente</em> pueda admitir.</p></li>
<li><p>Se debe utilizar preferiblemente la estrategia <strong>EAFP</strong> de manejo de excepciones para lidiar con valores de tipo <em>inesperado</em> en los parámetros de entrada.</p></li>
<li><p>Para una programación más avanzada, se puede hacer uso de la <strong>introspección</strong> de Python para <strong>adaptar</strong> el comportamiento de la función, de una manera coherente con el propósito de <strong>cohesión</strong> de la misma, según el valor que reciba.</p></li>
</ul>
</li>
</ul>
<hr class="docutils" />
<p><a id='Temas_avanzados'></a></p>
</div>
<div class="section" id="temas-avanzados-y-bibliografia-especifica">
<h2>Temas avanzados y bibliografía específica<a class="headerlink" href="#temas-avanzados-y-bibliografia-especifica" title="Permalink to this headline">¶</a></h2>
<p>Hemos visto que Python trata a las funciones como un <strong>objeto</strong> más, que tiene la peculiaridad de contener código ejecutable. Para Python, las funciones son <em>ciudadanos de primera clase</em> como se suele decir en la literatura especializada. Se pueden asignar funciones a variables y pasarlas a otras funciones. El concepto de funciones de nivel superior es básico en el paradigma de <strong>programación funcional</strong> que Python soporta. Aquí se han dado algunos elementos que <em>sugieren</em> la potencialidad de este tipo de paradigma, pero el tema es mucho más profundo y rebasa los límites de este curso introductorio.
Por ejemplo, es posible:</p>
<ul class="simple">
<li><p>Definir funciones dentro de otras funciones.</p></li>
<li><p>Devolver funciones mediante <code class="docutils literal notranslate"><span class="pre">return</span></code>.</p></li>
</ul>
<p>Estas y otras posibilidades que abren la puerta a una forma aún más abstracta, potente y productiva de programar. A expensas, desde luego, de una mayor complejidad conceptual.</p>
<p>El alumno interesado puede proseguir el estudio de estos temas, por ejemplo, en el libro <a class="reference external" href="https://composingprograms.com/pages/11-getting-started.html"><strong>Composing Programs</strong></a> que se encuentra disponible en línea.</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./notebooks\17_Funciones_conceptos_avanzados"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Félix Miguel Trespaderne / Rogelio Mazaeda Echevarría<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="../../_static/js/index.3da636dd464baa7582d2.js"></script>


    
  </body>
</html>